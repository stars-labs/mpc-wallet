use frost_secp256k1::Secp256K1Sha256;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Mutex;
use tui_node::handlers::session_handler::{
    BlockchainConfig, WalletCreationMode, WalletSessionConfig,
};
use tui_node::utils::state::{AppState, InternalCommand};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Setup logging
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .with_line_number(true)
        .init();

    // Get device ID from args
    let args: Vec<String> = std::env::args().collect();
    let device_id = args.get(1).cloned().unwrap_or_else(|| "mpc-1".to_string());
    let is_creator = device_id == "mpc-1";

    println!("===========================================");
    println!("Security Test: {}", device_id);
    println!("===========================================");
    println!();

    // Create app state
    let app_state = Arc::new(Mutex::new(AppState::<Secp256k1Sha256>::new(
        device_id.clone(),
    )));

    // Create command channel
    let (internal_cmd_tx, mut internal_cmd_rx) =
        tokio::sync::mpsc::unbounded_channel::<InternalCommand<Secp256k1Sha256>>();
    let (ws_msg_tx, mut ws_msg_rx) = tokio::sync::mpsc::unbounded_channel();

    // Start WebSocket connection
    let ws_url = "ws://localhost:3000";
    println!("Connecting to signal server at {}", ws_url);

    let app_state_clone = Arc::clone(&app_state);
    let internal_cmd_tx_clone = internal_cmd_tx.clone();
    let device_id_clone = device_id.clone();

    // WebSocket handler task
    tokio::spawn(async move {
        use futures_util::{SinkExt, StreamExt};
        use tokio_tungstenite::connect_async;
        use tokio_tungstenite::tungstenite::Message;

        let (mut ws_stream, _) = connect_async(ws_url).await.expect("Failed to connect");
        println!("Connected to WebSocket server");

        // Send device registration
        let register_msg = webrtc_signal_server::ClientMsg::RegisterDevice {
            device_id: device_id_clone.clone(),
        };
        let msg_str = serde_json::to_string(&register_msg).unwrap();
        ws_stream.send(Message::Text(msg_str)).await.unwrap();

        // Handle incoming messages
        while let Some(msg) = ws_stream.next().await {
            if let Ok(Message::Text(text)) = msg {
                if let Ok(server_msg) =
                    serde_json::from_str::<webrtc_signal_server::ServerMsg>(&text)
                {
                    match server_msg {
                        webrtc_signal_server::ServerMsg::Relay { from, data } => {
                            println!("📥 Received relay from {}", from);

                            // Try to parse as WebSocketMessage
                            if let Ok(ws_msg) = serde_json::from_value::<
                                tui_node::protocal::signal::WebSocketMessage,
                            >(data.clone())
                            {
                                use tui_node::protocal::signal::WebSocketMessage;
                                match ws_msg {
                                    WebSocketMessage::SessionProposal(proposal) => {
                                        println!(
                                            "📨 Received SessionProposal: {}",
                                            proposal.session_id
                                        );
                                        println!(
                                            "   Total: {}, Threshold: {}",
                                            proposal.total, proposal.threshold
                                        );
                                        println!("   Proposer: {}", proposal.proposer_device_id);

                                        // Check if we should auto-join (we shouldn't!)
                                        let mut state = app_state_clone.lock().await;
                                        let should_auto_join = state.session.is_none()
                                            && proposal.participants.len()
                                                < proposal.total as usize;

                                        if should_auto_join {
                                            println!(
                                                "❌ SECURITY VIOLATION: Would have auto-joined!"
                                            );
                                        } else {
                                            println!(
                                                "✅ SECURE: Not auto-joining without user consent"
                                            );
                                        }
                                    }
                                    WebSocketMessage::SessionAnnouncement(announcement) => {
                                        println!(
                                            "📢 Received SessionAnnouncement: {}",
                                            announcement.session_code
                                        );
                                        println!("✅ SECURE: Not auto-joining announced session");
                                    }
                                    _ => {}
                                }
                            }
                        }
                        webrtc_signal_server::ServerMsg::SessionAnnouncement { session_info } => {
                            if let Ok(announcement) = serde_json::from_value::<
                                tui_node::protocal::signal::SessionAnnouncement,
                            >(session_info)
                            {
                                println!(
                                    "📢 Session available: {} ({}/{})",
                                    announcement.session_code,
                                    announcement.participants_joined,
                                    announcement.total
                                );
                                println!(
                                    "✅ SECURE: Session requires explicit user action to join"
                                );
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
    });

    // Wait a bit for connection
    tokio::time::sleep(Duration::from_secs(1)).await;

    if is_creator {
        println!("Creating test session as mpc-1...");

        // Create a wallet session
        let session_config = WalletSessionConfig {
            wallet_name: "security_test_wallet".to_string(),
            description: Some("Testing security fix".to_string()),
            total: 3,
            threshold: 2,
            curve_type: "secp256k1".to_string(),
            mode: WalletCreationMode::Online,
            timeout_hours: 1,
            auto_discovery: true,
            blockchain_config: vec![BlockchainConfig {
                blockchain: "ethereum".to_string(),
                network: "testnet".to_string(),
                enabled: true,
                chain_id: Some(11155111),
            }],
        };

        // Create and announce session
        println!("📤 Creating and announcing session...");
        tui_node::handlers::session_handler::handle_propose_wallet_session(
            session_config,
            Arc::clone(&app_state),
            internal_cmd_tx.clone(),
            device_id.clone(),
        )
        .await?;

        println!("✅ Session created and announced");
        println!();
        println!("Waiting for other nodes to receive announcement...");
    } else {
        println!("Waiting for session announcements...");
        println!(
            "This node ({}) should NOT auto-join any sessions",
            device_id
        );
    }

    // Process internal commands
    tokio::spawn(async move {
        while let Some(cmd) = internal_cmd_rx.recv().await {
            match cmd {
                InternalCommand::SendToServer(msg) => {
                    let msg_str = serde_json::to_string(&msg).unwrap();
                    println!("📤 Sending: {}", msg_str);
                    ws_msg_tx.send(msg).unwrap();
                }
                InternalCommand::InitiateWebRTCConnections => {
                    println!("⚠️ WebRTC connection initiation requested");
                    println!("   This should only happen after explicit user consent!");
                }
                _ => {}
            }
        }
    });

    // Run for 10 seconds to observe behavior
    println!();
    println!("Running for 10 seconds to observe security behavior...");
    println!();

    for i in 1..=10 {
        tokio::time::sleep(Duration::from_secs(1)).await;
        if i % 3 == 0 {
            let state = app_state.lock().await;
            println!("[{}s] Current state:", i);
            println!("  - In session: {}", state.session.is_some());
            if let Some(ref session) = state.session {
                println!("  - Session ID: {}", session.session_id);
                println!("  - Participants: {:?}", session.participants);
                println!("  - Accepted: {:?}", session.accepted_devices);
            }
            println!("  - Invites: {}", state.invites.len());
            println!("  - Available sessions: {}", state.available_sessions.len());
        }
    }

    println!();
    println!("===========================================");
    println!("Test Complete for {}", device_id);
    println!("===========================================");
    println!();
    println!("Security Summary:");

    let final_state = app_state.lock().await;
    if !is_creator && final_state.session.is_none() {
        println!("✅ PASS: {} did not auto-join any sessions", device_id);
    } else if !is_creator && final_state.session.is_some() {
        println!(
            "❌ FAIL: {} auto-joined a session without consent!",
            device_id
        );
    } else if is_creator {
        println!("ℹ️ {} created the session (expected)", device_id);
    }

    Ok(())
}
