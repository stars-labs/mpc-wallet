{
  "id": "c4f2195a-dc35-4959-ad64-a53613519c0f",
  "title": "Popup State Persistence Fix",
  "details": "## Popup State Disappearing Issue - Root Cause & Fix\n\n### Issue Description:\nWhen users reopened the popup in the MPC wallet Chrome extension, the state would disappear and the popup would show as disconnected from the background script, losing all connection status, session information, and device lists.\n\n### Root Cause Analysis:\nThe issue was a **race condition** in the popup initialization process:\n\n1. **StateManager Async Loading**: StateManager loads persisted state asynchronously from Chrome storage in its constructor\n2. **Popup Connection Timing**: When popup connects via `chrome.runtime.connect()`, StateManager might still be loading state\n3. **Queuing Mechanism**: If state isn't loaded, popup gets queued in `pendingPopupPorts`\n4. **Disconnect Handling**: Queued ports had no disconnect handler, causing memory leaks and potential cleanup issues\n5. **Insufficient Timeout**: Popup fallback timeout was only 1 second, which might not be enough for Chrome storage operations\n\n### Solution Implemented:\n\n#### 1. Enhanced StateManager Logging & Port Management:\n- Added comprehensive logging throughout state loading process\n- Added disconnect handlers for queued popup ports to prevent memory leaks\n- Improved error handling in `processPendingPopupPorts()`\n\n#### 2. Improved Popup Initialization:\n- Increased fallback timeout from 1 to 2 seconds to account for async state loading\n- Added proper timeout cleanup when state is received or port disconnects\n- Enhanced logging for debugging connection timing issues\n\n#### 3. Code Changes Made:\n\n**StateManager.ts:**\n```typescript\n// Enhanced constructor logging\nconstructor(initialState?: Partial<AppState>) {\n    console.log(\"[StateManager] Constructor - starting async state loading...\");\n    // ...\n}\n\n// Improved addPopupPort with disconnect handler for queued ports\naddPopupPort(port: chrome.runtime.Port): void {\n    if (!this.isStateLoaded) {\n        this.pendingPopupPorts.push(port);\n        // NEW: Add disconnect handler for queued ports\n        port.onDisconnect.addListener(() => {\n            const index = this.pendingPopupPorts.indexOf(port);\n            if (index > -1) {\n                this.pendingPopupPorts.splice(index, 1);\n            }\n        });\n        return;\n    }\n    this.addPopupPortInternal(port);\n}\n```\n\n**App.svelte:**\n```typescript\nonMount(async () => {\n    let fallbackTimeoutId: number;\n    \n    port.onMessage.addListener((message) => {\n        if (message.type === \"initialState\" && !stateReceived) {\n            stateReceived = true;\n            // NEW: Clear fallback timeout when state received\n            if (fallbackTimeoutId) {\n                clearTimeout(fallbackTimeoutId);\n            }\n        }\n        handleBackgroundMessage(message);\n    });\n\n    // NEW: Increased timeout and proper cleanup\n    fallbackTimeoutId = setTimeout(() => {\n        // fallback logic\n    }, 2000); // Increased from 1s to 2s\n});\n```\n\n### Technical Details:\n- **Race Condition**: StateManager async state loading vs immediate popup connection\n- **Memory Leaks**: Queued ports without disconnect handlers\n- **Timing Issues**: Insufficient fallback timeout for Chrome storage operations\n- **Error Handling**: Improved error handling in pending port processing\n\n### Testing Verification:\n- Popup state should now persist properly when reopened\n- No memory leaks from disconnected queued ports\n- Better logging for debugging any remaining timing issues\n- Fallback mechanism more reliable with longer timeout\n\nThis fix addresses the core issue where popup state would disappear on reopen, ensuring consistent user experience and proper state management across popup sessions.",
  "category": "bugfix",
  "dateCreated": "2025-06-16T11:41:45.722Z",
  "dateUpdated": "2025-06-16T11:41:45.722Z"
}