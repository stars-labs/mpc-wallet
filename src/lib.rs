use getrandom::getrandom;
use hex;
use k256::ecdsa::{SigningKey, signature::Signer};
use sha3::{Digest, Keccak256};
use wasm_bindgen::prelude::*; // use getrandom instead of rand

// Import the `window.alert` function from the Web.
#[wasm_bindgen]
extern "C" {
    fn alert(s: &str);
}

// Export a `greet` function from Rust to JavaScript, that alerts a
// hello message.
#[wasm_bindgen]
pub fn greet(name: &str) {
    alert(&format!("Hello, {}!", name));
}

#[wasm_bindgen]
pub fn generate_priv_key() -> String {
    loop {
        let mut priv_bytes = [0u8; 32];
        getrandom(&mut priv_bytes).expect("random generation failed");
        // Check if the generated bytes form a valid secp256k1 private key
        if SigningKey::from_bytes((&priv_bytes).into()).is_ok() {
            return format!("0x{}", hex::encode(priv_bytes));
        }
        // else, loop and try again
    }
}

#[wasm_bindgen]
pub fn get_eth_address(priv_hex: &str) -> String {
    // Remove optional "0x" prefix if present
    let priv_hex = priv_hex.strip_prefix("0x").unwrap_or(priv_hex);
    let priv_bytes = match hex::decode(priv_hex) {
        Ok(bytes) => bytes,
        Err(_) => return String::from(""),
    };
    if priv_bytes.len() != 32 {
        return String::from("");
    }
    let priv_bytes: [u8; 32] = match priv_bytes.try_into() {
        Ok(arr) => arr,
        Err(_) => return String::from(""),
    };
    let signing_key = match SigningKey::from_bytes((&priv_bytes).into()) {
        Ok(sk) => sk,
        Err(_) => return String::from(""),
    };
    let verify_key = signing_key.verifying_key();
    let pubkey = verify_key.to_encoded_point(false);
    let pubkey_bytes = pubkey.as_bytes();
    // Ethereum address: keccak256(pubkey[1..])[12..]
    let hash = Keccak256::digest(&pubkey_bytes[1..]);
    let address = &hash[12..];
    format!("0x{}", hex::encode(address))
}

#[wasm_bindgen]
pub fn personal_sign(priv_hex: &str, message: &str) -> String {
    alert(&format!("personal_sign priv_hex: {}", priv_hex));
    let priv_bytes = match hex::decode(priv_hex) {
        Ok(bytes) => bytes,
        Err(_) => {
            alert("Failed to decode private key hex");
            return String::from("");
        }
    };
    let priv_bytes: [u8; 32] = match priv_bytes.try_into() {
        Ok(arr) => arr,
        Err(_) => {
            alert("Private key is not 32 bytes");
            return String::from("");
        }
    };
    let signing_key = match SigningKey::from_bytes((&priv_bytes).into()) {
        Ok(sk) => sk,
        Err(_) => {
            alert("Failed to create signing key");
            return String::from("");
        }
    };
    // Ethereum signed message prefix
    let prefix = format!("\x19Ethereum Signed Message:\n{}", message.len());
    let mut eth_message = prefix.into_bytes();
    eth_message.extend_from_slice(message.as_bytes());
    let hash = Keccak256::digest(&eth_message);
    let signature: k256::ecdsa::Signature = signing_key.sign(&hash);
    format!("0x{}", hex::encode(signature.to_bytes()))
}
